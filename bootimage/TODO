$Id: TODO,v 1.13 2004/06/30 19:19:44 fare Exp $

Kernel 2.4
* move on, dude!
* maybe fix issues (that may reappear in 2.6?):
 * the APM kill-the-machine-if-kapmd-killed bug if still present
 * make the cursor visible by default

Kernel 2.6
* port the keyboard driver
* ensure the mouse driver works
* port the sa1101 driver
* port and fix the apm driver
* port and fix the PCMCIA driver
* ensure that backlight control works on fb
* fix the above issues from kernel 2.4 if they are still there.
* make the USB driver work
* make the sound driver work
* play nicer with booting to/from WinCE
* get external VGA working and/or some swap-on-VRAM
* get modem working?
* get some spiffy 802.11g card working!

Bootdisk
* have pcmcia and busybox from CVS.
* include kernel 2.6 module support in busybox configuration.
* ensure busybox sh correctly reads /etc/profile at startup.
* make the initrd work with udev ???
* use early-userspace on kernel 2.6 ???

Userland
* gather a sensible base for userland (?)
* maybe based on OE? on uwoody?

Web site
* have a cron job update the web site from CVS.

Bootloader
* build a gcc toolchain for arm-wince-pe ???
* we imported the linexec source code as j820boot, to be ported to gcc

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
apm: do something
2.4 => kernel/arch/arm/mach-sa1100/apm.c
2.6 => kernel/arch/arm/mach-sa1100/jornada820.c
   kernel/arch/arm/kernel/apm.c
new apm_power_info structure

--- arch/arm/mach-sa1100/apm.c  22 Feb 2004 03:41:28 -0000
   1.1.1.1
+++ arch/arm/mach-sa1100/apm.c  4 Mar 2004 08:45:07 -0000       1.2
@@ -168,6 +168,9 @@
 #ifdef CONFIG_IPAQ_HANDHELD
             h3600_apm_get_power_status(ac_line_status,
   battery_status, battery_
flag, battery_percentage, battery_life);
 #endif
+#ifdef CONFIG_SA1100_JORNADA820
+            j820_apm_get_power_status(ac_line_status, battery_status,
   battery_f
lag, battery_percentage, battery_life);
+#endif
        return APM_SUCCESS;
 }

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
video/sa1100fb.c

ensure that somewhere in
extern void (*sa1100fb_backlight_power)(int on);
there is

#ifdef CONFIG_SA1100_JORNADA820	
        GPSR = GPIO_JORNADA820_BACKLIGHTON;
#endif

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
arch/arm/mach-sa1100/sa1101.c
update IRQ handling to new API... read Documentation/arm/Interrupts
avoid use of irq_desc and use request_irq() instead???
call set_irq_flags(irq,IRQF_VALID|...)???

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
pcmcia:
in sa1100.h find out what happened to
extern struct pcmcia_low_level jornada820_pcmcia_ops;

drivers/pcmcia/sa1100_generic.c:74: error: `pcmcia_jornada820_init' undeclared here (not in a function)
drivers/pcmcia/sa1100_generic.c:74: error: initializer element is not constant
drivers/pcmcia/sa1100_generic.c:74: error: (near initialization for `sa11x0_pcmcia_hw_init[0]')
make[2]: *** [drivers/pcmcia/sa1100_generic.o] Error 1

drivers/pcmcia/sa1100_jornada820.c:23: warning: `struct pcmcia_state_array' declared inside parameter list
drivers/pcmcia/sa1100_jornada820.c:23: warning: its scope is only this definition or declaration, which is probably not what you want
drivers/pcmcia/sa1100_jornada820.c: In function `jornada820_pcmcia_socket_state':
drivers/pcmcia/sa1100_jornada820.c:26: error: dereferencing pointer to incomplete type

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
drivers/char/keyboard.c:1011:2: warning: #warning "Cannot generate
   rawmode keyboard for your architecture yet."
Should we just ignore this???

j820_keyb.c:
conversion to 2.6 style done by Matan Ziv-Av

 Maybe special-case the Alt+arrow = PgUp, PgDn, Beg, End mappings? (?)
 Maybe special-case the On/Off key (?)
 Have a SysRQ button.
 Recognize as such the special button on the back?

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
make a serio/sa1101ps2.c ???

 take inspiration from sa1111ps2.c
 glue the code together, including psmouse. Howsitdone?
 Apparently, when registering the struct serio *serio, we have
 serio->type == SERIO_8042 or SERIO_PS_PSTHRU, and in the keyboard and
 mouse driver, in .connect, we switch (serio->type & SERIO_TYPE).
 serio/serio.c#serio_find_dev() will do the rest...

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
Add sleep/wakeup functions for all our drivers,
so as to support swsusp.

------>8------>8------>8------>8------>8------>8------>8------>8------>8------
